<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FPS ‚Äì WASD + Maus, 3D-Welt, Waves, T√ºrme & Upgrades</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color:#e6edf3; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #hud { position:fixed; inset:0; pointer-events:none; }
    #hud * { pointer-events:auto; } /* Kinder klickbar lassen (zur Sicherheit) */
    #top { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:12px; justify-content:space-between; align-items:center; }
    .pill { background:#0b1222cc; border:1px solid #1f2937; border-radius:999px; padding:8px 12px; box-shadow:0 8px 30px #0006; display:flex; gap:14px; align-items:center; pointer-events:auto; }
    #stats span{ white-space:nowrap; }

    #wave-info { color: #a3e635; font-weight: bold; }
    #shop { position:absolute; bottom:10px; right:10px; width:min(380px, 92vw); display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
    .btn { display:flex; justify-content:space-between; align-items:center; gap:10px; padding:10px 12px; border-radius:14px; background:#0f172acc; border:1px solid #1f2937; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    .btn:hover { transform: translateY(-1px); background:#111a33; }
    .btn .label{ font-weight:700; }
    .btn .cost{ opacity:.8; }
    #shop .btn { pointer-events:none; } /* Kaufen nur per 1‚Äì3 */

    #help { position:absolute; left:10px; bottom:10px; max-width:min(520px, 92vw); background:#0b1222cc; border:1px solid #1f2937; border-radius:14px; padding:12px; pointer-events:auto; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1222; border:1px solid #1f2937; border-radius:6px; padding:2px 6px; }
    .keycap { display:inline-flex; align-items:center; justify-content:center; min-width:1.4em; padding:2px 6px; border-radius:8px; border:1px solid #253049; background:#0b1222; font-weight:700; font-size:0.9em; margin-right:8px; }

    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000a; backdrop-filter: blur(2px); flex-direction:column; gap:10px; text-align:center; }
    #overlay.hide{ display:none; }
    #overlay button { pointer-events:auto; padding:12px 18px; border-radius:12px; border:1px solid #1f2937; background:#0f172a; color:#e6edf3; cursor:pointer; }
    canvas { display:block; width:100vw; height:100vh; }
    #diag { font-size:12px; opacity:.9; }
    #testResults { white-space:pre-wrap; text-align:left; max-width:min(680px, 90vw); background:#0b1222; border:1px solid #1f2937; border-radius:10px; padding:8px 10px; }
    #cross { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none; }
    #cross .hair { position:absolute; background:#cdd9e5; box-shadow: 0 0 4px #000a; }
    #cross .hair:nth-child(1) { width:2px; height:8px; left:-1px; top:-11px; } /* Top */
    #cross .hair:nth-child(2) { width:2px; height:8px; left:-1px; top:3px; }  /* Bottom */
    #cross .hair:nth-child(3) { width:8px; height:2px; top:-1px; left:-11px; } /* Left */
    #cross .hair:nth-child(4) { width:8px; height:2px; top:-1px; left:3px; }  /* Right */
    #hitmarker { position:absolute; width:16px; height:16px; top:-8px; left:-8px; opacity:0; transition: opacity 0.12s ease-out; }
    #hitmarker.active { opacity:1; transform: scale(1.1); }
    .marker-line { position:absolute; background:#fff; width:2px; height:8px; box-shadow: 0 0 5px #000; }
    .marker-line:nth-child(1) { top:-10px; left:-10px; transform: rotate(45deg); } /* Oben-Links */
    #hitmarker.headshot .marker-line { background-color: #ff4d4d; } /* Roter Hitmarker f√ºr Headshots */
    #hitmarker.headshot { transform: scale(1.3); }

    .marker-line:nth-child(2) { top:-10px; right:-10px; transform: rotate(-45deg); } /* Oben-Rechts */
    .marker-line:nth-child(3) { bottom:-10px; left:-10px; transform: rotate(-45deg); } /* Unten-Links */
    .marker-line:nth-child(4) { bottom:-10px; right:-10px; transform: rotate(45deg); } /* Unten-Rechts */

    #damage-vignette {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, rgba(255,0,0,0) 40%, rgba(200,0,0,0.5) 100%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease-out;
    }

    #notifications { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 8px; z-index: 10; }
    .notification { background: #c0392bcc; color: white; padding: 8px 16px; border-radius: 8px; box-shadow: 0 4px 15px #0008; opacity: 1; transition: opacity 0.5s ease-out, transform 0.5s ease-out; transform: translateY(0); }
    .notification.info { background: #27ae60cc; }
    .notification.fade-out { opacity: 0; transform: translateY(-20px); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/",
      "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/GLTFLoader.js",
      "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.0/build/index.module.js",
      "BufferGeometryUtils": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/utils/BufferGeometryUtils.js"
    }
  }
  </script>
</head>
<body>
  <div id="overlay">
    <h1>FPS Demo (WASD + Maus)</h1>
    <p id="diag">Lade Engine ‚Ä¶</p>
    <p>Steuerung: <span class="kbd">WASD</span> bewegen, <span class="kbd">Maus</span> umsehen, <span class="kbd">LMT</span> schie√üen,<br/>
       <span class="keycap">1</span> Turm, <span class="keycap">2</span> Schaden, <span class="keycap">3</span> Feuerrate,
       <span class="kbd">T</span> Turm platzieren, <span class="kbd">P</span> Pause, <span class="kbd">R</span> Neustart.</p>
    <button id="startBtn" disabled>Start</button>
    <div id="testResults" hidden></div>
  </div>
  <div id="cross">
    <div class="hair"></div>
    <div class="hair"></div>
    <div class="hair"></div>
    <div class="hair"></div>
    <div id="hitmarker">
      <div class="marker-line"></div>
      <div class="marker-line"></div>
      <div class="marker-line"></div>
      <div class="marker-line"></div>
    </div>
  </div>

  <div id="hud">
    <div id="damage-vignette"></div>
    <div id="notifications"></div>
    <div id="top">
      <div id="stats" class="pill">
        <span>‚ù§Ô∏è HP: <b id="hp">100</b></span>
        <span>üí∞ Credits: <b id="credits">0</b></span>
        <span>üåä Wave: <b id="wave">1</b></span>
        <span>üî´ DMG: <b id="dmg">10</b></span>
        <span>‚ö° Rate: <b id="rate">6/s</b></span>
        <span>üõ°Ô∏è T√ºrme: <b id="turrets">0</b></span>
        <span>üßü Zombies: <b id="zombies">0</b></span>
        <span id="wave-info" style="display: none;"></span>
      </div>
      <div class="pill" style="gap:8px;">
        <button id="pauseBtn" class="btn"><span class="label">‚è∏Ô∏è Pause</span></button>
        <button id="restartBtn" class="btn"><span class="label">üîÅ Neustart</span></button>
      </div>
    </div>

    <div id="shop">
      <button class="btn" id="buyTurret"><span class="keycap">1</span><span class="label">üõ†Ô∏è Turm kaufen</span><span>Auto-Ziel</span><span class="cost" id="turretCost">Kosten: 100</span></button>
      <button class="btn" id="upgradeDmg"><span class="keycap">2</span><span class="label">üí• Schaden upgraden</span><span>+5 Schaden</span><span class="cost" id="dmgCost">Kosten: 80</span></button>
      <button class="btn" id="upgradeRate"><span class="keycap">3</span><span class="label">‚ö° Feuerrate upgraden</span><span>+1/s</span><span class="cost" id="rateCost">Kosten: 90</span></button>
    </div>

    <div id="help">
      <b>Hinweise</b>: WASD + Maus. Kaufen per Tasten: <span class="keycap">1</span> Turm, <span class="keycap">2</span> Schaden, <span class="keycap">3</span> Feuerrate. Turm platzieren: <span class="kbd">T</span> (auf Boden zielen). Pause <span class="kbd">P</span>, Neustart <span class="kbd">R</span>.
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import { GLTFLoader } from 'GLTFLoader'; // GLTFLoader ist ein Addon, daher sollte der Importpfad angepasst werden
    import { MeshBVH } from 'three-mesh-bvh';
    import { mergeGeometries } from 'BufferGeometryUtils';

    const diag = document.getElementById('diag');
    const startBtn = document.getElementById('startBtn');
    const hitmarkerEl = document.getElementById('hitmarker');

    // --- Renderer/Scene/Camera ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMappingExposure = 1.8; // Tag-hell
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const CAMERA_HEIGHT = 1.6;
    camera.position.set(0, CAMERA_HEIGHT, 5);

    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const weaponMuzzle = new THREE.Object3D(); // Leeres Objekt f√ºr die M√ºndungsposition
    // --- Waffenmodell ---
    function loadWeapon() {
      const loader = new GLTFLoader();
      loader.load(
        './models/Zombie_kit/Weapons/glTF/Rifle.gltf',
        (gltf) => {
          const weapon = gltf.scene;
          weapon.traverse(node => {
            if (node.isMesh) {
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
          // Position, Rotation und Skalierung anpassen, damit es gut in der Ego-Perspektive aussieht
          weapon.position.set(0.25, -0.4, -0.8);
          weapon.rotation.y = Math.PI; // Waffe um 180 Grad drehen
          weapon.scale.set(0.7, 0.7, 0.7);
          weaponMuzzle.position.set(0, 0.05, 0.7); // M√ºndungsposition an das Ende des Laufs verschoben
          weapon.add(weaponMuzzle);
          camera.add(weapon); // Waffe an die Kamera heften
        },
        undefined,
        (error) => {
          console.error('Waffe konnte nicht geladen werden, erstelle prozedurale Waffe als Fallback.', error);
          createProceduralWeapon(); // Fallback
        }
      );
    }
    loadWeapon();
    // --- Licht ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const hemi = new THREE.HemisphereLight(0xffffff, 0x87ceeb, 1.0); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.4); dir.position.set(30, 50, -10); dir.castShadow = true; scene.add(dir);
 
    // --- Arena ---
    const walls = new THREE.Group(); // Wird f√ºr Turm-Platzierung beibehalten, aber anders genutzt
    let worldBVH = null;
    scene.add(walls);

    function loadMap() {
      const loader = new GLTFLoader();
      // Lade die .gltf-Datei aus dem von dir angegebenen Ordner.
      loader.load('./models/Maps/city_of_the_sky/scene.gltf', (gltf) => {
        const mapModel = gltf.scene;

        // --- Modell Normalisierung ---
        // 1. Setze die Transformationen des Wurzelknotens zur√ºck, um Probleme zu vermeiden.
        mapModel.scale.set(1, 1, 1);
        mapModel.rotation.set(0, 0, 0);
        mapModel.position.set(0, 0, 0);
        mapModel.updateMatrixWorld(true); // Erzwinge die Aktualisierung der Matrizen

        // 2. Erstelle eine BoundingBox um das gesamte Modell, um es zu zentrieren und zu skalieren.
        const box = new THREE.Box3().setFromObject(mapModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // 3. Verschiebe das Modell so, dass sein Zentrum am Ursprung (0,0,0) liegt.
        mapModel.position.sub(center);

        // 4. Skaliere das Modell auf eine vern√ºnftige Gr√∂√üe.
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 150 / maxDim; // Zielgr√∂√üe von 150 Einheiten
        mapModel.scale.setScalar(scale);

        // F√ºge das normalisierte Modell zur Szene hinzu
        scene.add(mapModel);
        mapModel.updateMatrixWorld(true); // Erneut aktualisieren nach allen √Ñnderungen

        // --- BVH Erstellung (jetzt mit korrekten Transformationen) ---
        const geometries = [];
        mapModel.traverse(node => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            const clonedGeom = node.geometry.clone();
            clonedGeom.applyMatrix4(node.matrixWorld);
            geometries.push(clonedGeom);
          }
        });

        worldBVH = new MeshBVH(mergeGeometries(geometries, false));
        raycaster.firstHitOnly = true;
        console.log('Karte normalisiert und BVH erstellt.');
        findSpawnPoint(mapModel);

      }, undefined, (error) => {
        console.error('Karte konnte nicht geladen werden:', error);
      });
    }

    function findSpawnPoint(mapModel) {
      const box = new THREE.Box3().setFromObject(mapModel);
      for (let i=0; i<12; i++) {
        const x = THREE.MathUtils.lerp(box.min.x, box.max.x, Math.random());
        const z = THREE.MathUtils.lerp(box.min.z, box.max.z, Math.random());
        const y = box.max.y + 50;
        raycaster.set(new THREE.Vector3(x,y,z), new THREE.Vector3(0,-1,0));
        const hits = worldBVH ? [worldBVH.raycastFirst(raycaster.ray)].filter(h => h) : [];
        if (hits.length) {
          spawnPos.copy(hits[0].point).y += CAMERA_HEIGHT;
          console.log('Spawn via Sampling:', spawnPos);
          return;
        }
      }
      console.warn('Sampling fand nichts ‚Äì Fallback bleibt.');
    }

    // Lade die 3D-Karte anstelle der prozeduralen Generierung
    loadMap();

    let spawnPos = new THREE.Vector3(0, CAMERA_HEIGHT, 5); // Fallback-Spawn, wird √ºberschrieben

    // --- State & HUD ---
    const el = (id)=>document.getElementById(id);
    const state = {
      running:false, gameOver:false, hp:100, credits:0, wave:0, time:0,
      damage:10, fireRate:6, lastShot:0,
      enemies:[], turrets:[], projectiles:[], costs:{ turret:100, dmg:80, rate:90 },
      speed:10, friction:10, vel:new THREE.Vector3(),
      waveInProgress: false, timeUntilNextWave: 5, onGround: true,
      timeUntilAmbientSpawn: 15, // Timer f√ºr zus√§tzliche Zombies
    };
    const hpEl=el('hp'), credEl=el('credits'), waveEl=el('wave'), dmgEl=el('dmg'), rateEl=el('rate'), turEl=el('turrets');
    const waveInfoEl = el('wave-info');
    const overlay = el('overlay');
    function updateHUD(){
      hpEl.textContent = Math.max(0, Math.ceil(state.hp));
      credEl.textContent = state.credits;
      waveEl.textContent = state.wave;
      dmgEl.textContent = state.damage;
      rateEl.textContent = `${state.fireRate.toFixed(1)}/s`;
      turEl.textContent = state.turrets.length;
      el('zombies').textContent = state.enemies.length;
      el('turretCost').textContent = `Kosten: ${state.costs.turret}`;
      el('dmgCost').textContent = `Kosten: ${state.costs.dmg}`;
      el('rateCost').textContent = `Kosten: ${state.costs.rate}`;
      el('buyTurret').disabled = state.credits < state.costs.turret;
      el('upgradeDmg').disabled = state.credits < state.costs.dmg;
      el('upgradeRate').disabled = state.credits < state.costs.rate || state.fireRate>=16;

      if (!state.waveInProgress && state.enemies.length === 0 && !state.gameOver) {
        waveInfoEl.style.display = 'inline';
        waveInfoEl.textContent = `N√§chste Welle in ${Math.ceil(state.timeUntilNextWave)}s`;
      } else {
        waveInfoEl.style.display = 'none';
      }
    }

    // --- Benachrichtigungen ---
    const notificationsEl = document.getElementById('notifications');
    function showNotification(message, duration = 2000, type = 'info') {
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.classList.add('notification');
      if (type === 'info') {
        notification.classList.add('info');
      }
      
      notificationsEl.appendChild(notification);

      setTimeout(() => {
          notification.classList.add('fade-out');
          setTimeout(() => {
              notificationsEl.removeChild(notification);
          }, 500); // Warte auf die Fade-Out-Animation
      }, duration);
    }

    // --- Schadens-Effekt ---
    const damageVignetteEl = document.getElementById('damage-vignette');
    let damageTimeout;
    function showDamageEffect() {
      if (damageTimeout) clearTimeout(damageTimeout);
      damageVignetteEl.style.opacity = '1';
      damageTimeout = setTimeout(() => {
        damageVignetteEl.style.opacity = '0';
      }, 120); // Dauer des Effekts in ms
    }

    // --- Toon Zombie Materialien ---
    function toonMat(hex) {
      const c = new THREE.Color(hex);
      const m = new THREE.MeshToonMaterial({ color: c, gradientMap: null });
      m.onBeforeCompile = (shader) => {
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <tonemapping_fragment>',
          `
          float l = clamp( dot( normalize( vViewPosition ), vec3(0.0,0.0,1.0) ) * -1.0, 0.0, 1.0 );
          float stepL = l < 0.33 ? 0.15 : (l < 0.66 ? 0.55 : 0.95);
          gl_FragColor = vec4( outgoingLight * stepL, diffuseColor.a );
          #include <tonemapping_fragment>
          `
        );
      };
      return m;
    }

    // --- Gegner: Laden eines GLB-Modells ---
    const loader = new GLTFLoader();
    let zombieModel = null; // Hier speichern wir das geladene Modell
    let zombieAnimations = []; // Hier speichern wir die Animationen
    const animationMixers = []; // Ein Mixer f√ºr jeden Zombie

    // Wir laden das Modell nur einmal und klonen es dann f√ºr jeden neuen Zombie.
    loader.load(
      // URL zu einem kostenlosen Zombie-Modell. Du kannst hier jedes andere .glb Modell verwenden.
      './models/Zombie_kit/Characters/glTF/Zombie_Chubby.gltf', // Lade das Chubby-Zombie-Modell
      (gltf) => {
        zombieModel = gltf.scene;
        zombieAnimations = gltf.animations;  // Animationen aus der GLB-Datei speichern
        zombieModel.scale.set(0.8, 0.8, 0.8); // Modellgr√∂√üe anpassen

        // --- DEBUG: Knochenstruktur ausgeben ---
        zombieModel.traverse(node => {
          if (node.isSkinnedMesh) {
            console.log("SkinnedMesh gefunden:", node);
            const skeleton = node.skeleton;
            console.log("Bones des Skeletons:", skeleton.bones);
          }
        });
        // --- ENDE DEBUG ---

        console.log("Zombie-Modell geladen!");
        // Entferne den Debug-Code, nachdem wir die Knochennamen haben.
        const debugLog = document.getElementById('testResults');
        if (debugLog) debugLog.hidden = true;

        diag.textContent = 'Engine geladen ‚Äì bereit.';
        startBtn.disabled = false; // Aktiviere den Start-Button, wenn das Modell geladen ist.
      },
      undefined, // onProgress-Callback (nicht ben√∂tigt)
      (error) => console.error('Fehler beim Laden des Zombie-Modells:', error)
    );

    // --- Zombie-Klasse zur Kapselung der Gegnerlogik ---
    class Zombie {
      constructor(baseModel, baseAnimations, scene, waveConfig, playerPosition) {
        this.scene = scene;


        // 1. Modell klonen und Material einzigartig machen
        this.model = SkeletonUtils.clone(baseModel);
        this.model.traverse(node => {
          if (node.isMesh && node.material) {
            node.material = node.material.clone();
          }
        });
        // Wichtiger Link vom 3D-Objekt zur√ºck zur Klasseninstanz
        this.model.userData.parentInstance = this;

        // 2. Positionieren: Suche eine g√ºltige Spawn-Position auf der Karte.
        let spawnFound = false;
        for (let i = 0; i < 10; i++) { // Versuche es bis zu 10 Mal
          const angle = Math.random() * Math.PI * 2;
          const radius = 40 + Math.random() * 30; // Etwas gr√∂√üerer Radius
          const x = playerPosition.x + Math.cos(angle) * radius;
          const z = playerPosition.z + Math.sin(angle) * radius;

          const groundRay = new THREE.Raycaster(new THREE.Vector3(x, 500, z), new THREE.Vector3(0, -1, 0));
          const groundHit = worldBVH ? worldBVH.raycastFirst(groundRay.ray) : null;

          if (groundHit) {
            this.model.position.set(x, groundHit.point.y, z);
            spawnFound = true;
            break;
          }
        }
        if (!spawnFound) { // Fallback, wenn kein g√ºltiger Boden gefunden wurde
          console.warn("Konnte keine g√ºltige Spawn-Position f√ºr Zombie finden. Nutze Fallback.");
          const angle = Math.random() * Math.PI * 2;
          const radius = 35 + Math.random() * 20;
          this.model.position.x = playerPosition.x + Math.cos(angle) * radius;
          this.model.position.z = playerPosition.z + Math.sin(angle) * radius;
          this.model.position.y = playerPosition.y - CAMERA_HEIGHT; // Fallback auf H√∂he der Spielerf√º√üe
        }

        // 3. Animation und Geschwindigkeit basierend auf Animation
        this.mixer = new THREE.AnimationMixer(this.model);
        this.setupAnimation(baseAnimations, waveConfig.typeDistribution);

        // 4. Stats
        this.hp = (40 + Math.floor(state.wave * 4)) * waveConfig.hpMultiplier;
        this.hitTint = 0;
        this.headHitTint = 0;
        this.vel = new THREE.Vector3();
        this.isInitialized = false; // Flag f√ºr die erste Initialisierung

        // Array f√ºr unsere Knochen-Hitboxen
        this.hitboxes = [];

        // 5. Zur Szene hinzuf√ºgen
        this.scene.add(this.model);
      }

      setupAnimation(animations, distribution) {
        if (animations.length > 0) {
          const runAnims = animations.filter(anim => /run/i.test(anim.name));
          const walkAnims = animations.filter(anim => /walk/i.test(anim.name));
          const crawlAnims = animations.filter(anim => /crawl/i.test(anim.name));

          let animToPlay;
          const rand = Math.random(); // 0.0 to 1.0

          if (rand < distribution.run && runAnims.length > 0) {
            animToPlay = runAnims[Math.floor(Math.random() * runAnims.length)];
            this.speed = 8.0;
          } else if (rand < distribution.run + distribution.crawl && crawlAnims.length > 0) {
            animToPlay = crawlAnims[Math.floor(Math.random() * crawlAnims.length)];
            this.speed = 2.0; // Kriecher sind langsamer
            this.model.position.y += 0.5; // Offset, damit sie nicht im Boden spawnen
          } else if (walkAnims.length > 0) { // Der Rest sind "walk"
            animToPlay = walkAnims[Math.floor(Math.random() * walkAnims.length)];
            this.speed = 4.0;
          } else {
            animToPlay = animations[0];
            this.speed = 1.0;
          }

          if (animToPlay) {
            this.mixer.clipAction(animToPlay).play();
          }
        } else {
          this.speed = 1.0; // Fallback-Speed
        }
      }

      // Erstellt und heftet unsichtbare Hitboxen an die Knochen.
      setupHitboxes() {
        const headBone = this.model.getObjectByName('Head');
        const torsoBone = this.model.getObjectByName('Torso');

        if (headBone) {
          const headHitbox = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 8, 8), // Radius anpassen
            new THREE.MeshBasicMaterial({ visible: false })
          );
          headHitbox.userData.isHead = true;
          headHitbox.geometry.computeBoundingSphere(); // Erzwinge die Berechnung der Bounding Sphere
          headHitbox.userData.parentInstance = this;
          headBone.add(headHitbox);
          this.hitboxes.push(headHitbox);
        }

        if (torsoBone) {
          const bodyHitbox = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 8, 8), // Radius anpassen
            new THREE.MeshBasicMaterial({ visible: false })
          );
          bodyHitbox.position.y = -0.4; // Leicht nach unten verschieben, um den Torso besser abzudecken
          bodyHitbox.geometry.computeBoundingSphere(); // Erzwinge die Berechnung der Bounding Sphere
          bodyHitbox.userData.isHead = false;
          bodyHitbox.userData.parentInstance = this;
          torsoBone.add(bodyHitbox);
          this.hitboxes.push(bodyHitbox);
        }
      }


      takeDamage(damage, isHeadshot) {
        this.hp -= damage;
        if (isHeadshot) {
          this.headHitTint = 0.15;
        } else {
          this.hitTint = 0.15;
        }
        return this.hp <= 0; // Gibt true zur√ºck, wenn der Zombie tot ist
      }

      die() {
        if (this.isDying) return;
        this.isDying = true;
        this.mixer.stopAllAction();
        const deathClip = zombieAnimations.find(anim => anim.name === "Death");
        if (deathClip) {
          const action = this.mixer.clipAction(deathClip);
          action.setLoop(THREE.LoopOnce);
          action.clampWhenFinished = true;
          action.play();
        }
      }
      update(dt, playerPosition) {
        // Wenn der Zombie stirbt, nur die Animation abspielen und keine weitere Logik ausf√ºhren.
        if (this.isDying) {
          this.mixer.update(dt);
          return; // Stoppt die weitere Ausf√ºhrung der Methode
        }

        // Einmalige Initialisierung der Kollisionsgeometrie im ersten Frame
        if (!this.isInitialized) {
          this.setupHitboxes();
          this.isInitialized = true;
        }

        // --- Schwerkraft und Bodenhaftung ---
        this.vel.y -= 9.8 * dt * 2.5;
        this.model.position.y += this.vel.y * dt;

        // Strahl von leicht √ºber dem Zombie nach unten, um den Boden zu finden.
        // Das ist robuster, als vom Ursprung des Modells aus zu strahlen, falls es in den Boden sinkt.
        const groundRayOrigin = this.model.position.clone().add(new THREE.Vector3(0, 2.0, 0));
        const groundRay = new THREE.Raycaster(groundRayOrigin, new THREE.Vector3(0, -1, 0));
        const groundHit = worldBVH ? worldBVH.raycastFirst(groundRay.ray) : null;
        // Wenn der Boden nahe genug ist (innerhalb von 3 Einheiten, was 2 Einheiten Puffer nach oben und 1 nach unten gibt)
        if (groundHit && groundHit.distance < 3.0) {
          this.model.position.y = groundHit.point.y;
          this.vel.y = 0;
        }

        // Bewegung zum Spieler
        const toPlayer = new THREE.Vector3().subVectors(playerPosition, this.model.position);
        toPlayer.y = 0;
        const distance = toPlayer.length();

        if (distance > 0.01) {
          toPlayer.normalize();
          this.model.rotation.y = Math.atan2(toPlayer.x, toPlayer.z);
          
          // --- Verbesserte Kollisionsabfrage (Capsule-√§hnlich) ---
          const moveVec = toPlayer.multiplyScalar(this.speed * dt);
          const ZOMBIE_RADIUS = 0.4;
          const checkDistance = ZOMBIE_RADIUS + moveVec.length();

          // Pr√ºfe auf 3 H√∂hen: Kn√∂chel, H√ºfte, Kopf
          const heights = [0.2, 1.0, 1.6];
          let closestHit = null;

          for (const h of heights) {
            const origin = this.model.position.clone().add(new THREE.Vector3(0, h, 0));
            const collisionRay = new THREE.Raycaster(origin, toPlayer);
            const wallHit = worldBVH ? worldBVH.raycastFirst(collisionRay.ray) : null;

            if (wallHit && wallHit.distance < checkDistance) {
              if (!closestHit || wallHit.distance < closestHit.distance) {
                closestHit = wallHit;
              }
            }
          }

          if (closestHit) {
            const wallNormal = closestHit.face.normal;
            moveVec.sub(wallNormal.multiplyScalar(moveVec.dot(wallNormal))); // An der Wand entlang gleiten
          }
          this.model.position.add(moveVec);
        }



        // Treffer-Effekt
        if (this.hitTint > 0 || this.headHitTint > 0) {
          this.hitTint -= dt; this.headHitTint -= dt;
          this.model.traverse(node => {
            if (node.isMesh && node.material) {
              if (!node.userData.originalColor) node.userData.originalColor = node.material.color.clone();
              node.material.color.setHex(0xff6b6b);
            }
          });
        } else {
          this.model.traverse(node => {
            if (node.isMesh && node.material && node.userData.originalColor) {
              node.material.color.copy(node.userData.originalColor);
              delete node.userData.originalColor;
            }
          });
        }

        this.mixer.update(dt);
        return distance; // Distanz f√ºr Schadensberechnung zur√ºckgeben
      }

      dispose() {
        this.mixer.stopAllAction();
        this.scene.remove(this.model);
      }
    }

    async function spawnEnemy(waveConfig, playerPosition){
      if (!zombieModel) return; // Warten, bis das Modell geladen ist
      const zombie = new Zombie(zombieModel, zombieAnimations, scene, waveConfig, playerPosition);
      state.enemies.push(zombie);
    }

    function enemyAI(dt){
      for (let i=state.enemies.length-1;i>=0;i--){
        const e = state.enemies[i];
        e.update(dt, controls.getObject().position);

        // Zombies, die tot sind, nach einer Verz√∂gerung entfernen
        if (e.isDead) {
          e.dispose();
          state.enemies.splice(i, 1);
          continue;
        }

        // Sterbende Zombies k√∂nnen nicht mehr angreifen.
        if (e.isDying) continue;

        // Berechne die 3D-Distanz f√ºr den Angriff, um Angriffe durch den Boden zu verhindern.
        const playerPos = controls.getObject().position;
        const zombiePos = e.model.position;
        const attackDistance3D = playerPos.distanceTo(zombiePos);

        if (attackDistance3D < 1.5){ // Pr√ºfe die tats√§chliche 3D-Reichweite
          state.hp -= 15*dt;
          showDamageEffect(); // Visuelles Feedback f√ºr Schaden
          if (state.hp<=0){ gameOver(); } 
        }
      }
    }

    // --- Shooting (Raycaster) ---
    const raycaster = new THREE.Raycaster();
    function muzzleFlash(){ const light = new THREE.PointLight(0xffdd99, 2, 6); light.position.copy(camera.position); scene.add(light); setTimeout(()=>scene.remove(light), 60); }
    const sparks=[];
    function spawnSpark(pos, isHeadshot = false){
      const size = isHeadshot ? 0.25 : 0.05;
      const color = isHeadshot ? 0xffff00 : 0xff6b6b; // Gelb f√ºr Headshot, Rot f√ºr K√∂rper
      const life = isHeadshot ? 0.5 : 0.3;
      const particleCount = isHeadshot ? 5 : 1;

      for (let i = 0; i < particleCount; i++) {
        const g = new THREE.SphereGeometry(size * (Math.random() * 0.5 + 0.75), 6, 6);
        const m = new THREE.Mesh(g, new THREE.MeshBasicMaterial({ color: color, transparent:true }));
        m.position.copy(pos);
        const v = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2).normalize().multiplyScalar(isHeadshot ? 4 : 2);
        scene.add(m); sparks.push({m,v,life});
      }
    }
    function updateSparks(dt){ for (let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.m.position.addScaledVector(s.v, dt); s.v.y -= 9.8*dt; s.life-=dt; s.m.material.opacity = Math.max(0, s.life/0.3); if (s.life<=0){ scene.remove(s.m); sparks.splice(i,1); } } }
    function shoot(){
      const now = performance.now(); const interval = 1000/state.fireRate; if (now - state.lastShot < interval) return; state.lastShot = now;
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      
      // NEU: Ziele nur auf die unsichtbaren Hitboxen
      const allHitboxes = state.enemies.flatMap(e => e.hitboxes);
      const hits = raycaster.intersectObjects(allHitboxes);

      if (hits.length > 0) {
        const hit = hits[0]; // Der erste Treffer ist der n√§chste
        const hitObject = hit.object;
        const zombie = hitObject.userData.parentInstance;
        const point = hit.point;

        if (!zombie) return;

        const isHeadshot = hitObject.userData.isHead === true;
        const damage = isHeadshot ? state.damage * 2 : state.damage;
        const wasKilled = zombie.takeDamage(damage, isHeadshot);

        spawnSpark(point, isHeadshot);
        if (wasKilled && !zombie.isDying) {
          zombie.die();
          setTimeout(() => {
            zombie.isDead = true;
          }, 60000); // Zombie nach 1 Minute entfernen
          state.credits += Math.floor(10 + Math.random() * 5) + Math.floor(state.wave * 2);
        }
        // Visuelles Feedback (Hitmarker)
        if (hitmarkerEl) { if (isHeadshot) hitmarkerEl.classList.add('headshot'); hitmarkerEl.classList.add('active'); setTimeout(() => { hitmarkerEl.classList.remove('active', 'headshot'); }, 120); }
      }

      // Projektil-Effekt erstellen
      const muzzleWorldPos = new THREE.Vector3();
      weaponMuzzle.getWorldPosition(muzzleWorldPos);

      const projectileGeo = new THREE.SphereGeometry(0.04, 6, 4);
      const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff99, transparent: true });
      const projectile = new THREE.Mesh(projectileGeo, projectileMat);
      projectile.position.copy(muzzleWorldPos);

      const projectileDir = new THREE.Vector3().subVectors(raycaster.ray.at(100, new THREE.Vector3()), muzzleWorldPos).normalize();
      const projectileSpeed = 120;

      const p = { mesh: projectile, dir: projectileDir, speed: projectileSpeed, life: 0.8, isPlayer: true };
      state.projectiles.push(p);
      scene.add(projectile);

      muzzleFlash(); updateHUD();
    }

    // --- Turrets ---
    function makeTurret() { // Komplett neues Turm-Modell und -Logik
      const turretGroup = new THREE.Group();
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x34495e, metalness: 0.8, roughness: 0.4 });
      const gunMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, metalness: 0.7, roughness: 0.5 });

      // Basis (unbeweglich)
      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 0.3, 8), baseMat);
      base.position.y = 0.15;
      turretGroup.add(base);

      // Kleiner Zylinder als Verbindung
      const connector = new THREE.Mesh(new THREE.CylinderGeometry(0.27, 0.27, 0.3, 8), baseMat);
      connector.position.y = 0.45; // Auf der Basis (0.3 + 0.3/2)
      turretGroup.add(connector);

      // Schwenk-Teil (dreht sich horizontal)
      const swivel = new THREE.Group();
      swivel.position.y = 0.6; // Angehoben auf die Oberseite des Verbinders
      turretGroup.add(swivel);

      // Waffe (neigt sich vertikal)
      const gun = new THREE.Group();
      gun.position.y = 0.2;   // Waffe anheben, damit sie auf dem Schwenkpunkt sitzt
      gun.position.z = 0.25; // Waffe relativ zum Schwenkpunkt nach vorne versetzen (positive Z-Achse ist "vorne" wegen lookAt)
      const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.8), gunMat);
      gunBody.position.z = -0.2; // Waffenk√∂rper nach hinten versetzen
      gun.add(gunBody);
      swivel.add(gun);

      // L√§ufe (rotieren f√ºr Animation)
      const barrels = new THREE.Group();
      barrels.position.z = 0.4; // Vor dem Waffenk√∂rper positionieren
      const barrelGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8);
      const barrelRadius = 0.1;
      for (let i = 0; i < 6; i++) {
        const barrel = new THREE.Mesh(barrelGeo, baseMat);
        const angle = (i / 6) * Math.PI * 2;
        barrel.position.set(Math.cos(angle) * barrelRadius, Math.sin(angle) * barrelRadius, 0);
        barrel.rotation.x = Math.PI / 2;
        barrels.add(barrel);
      }
      gun.add(barrels);

      scene.add(turretGroup);
      return { base: turretGroup, swivel, gun, barrels, cooldown: 0, fireRate: 4.5, damage: Math.max(4, Math.floor(state.damage * 0.4)), range: 22, barrelRot: 0 };
    }
    function placeTurret(){
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = worldBVH ? [worldBVH.raycastFirst(raycaster.ray)].filter(h => h) : []; // Nutze BVH
      if (!hits.length) return;
      const hit = hits[0]; const t = makeTurret(); t.base.position.copy(hit.point).add(new THREE.Vector3(0, 0.15, 0)); state.turrets.push(t); updateHUD();
    }
    function turretsAct(dt) { // Neue, robuste Ziel- und Schusslogik
      for (const t of state.turrets) {
        t.cooldown -= dt;
        let target = null, distBest = Infinity;
        for (const e of state.enemies) { // Zombies haben jetzt `e.model` statt `e.m`
          const d = e.isDying ? Infinity : t.base.position.distanceTo(e.model.position);
          if (d < t.range && d < distBest) { distBest = d; target = e; } // `e.m` wurde zu `e.model`
        }
        
        const isShooting = target && t.cooldown <= 0;
        
        if (target) {
          const targetPos = target.model.position.clone().add(new THREE.Vector3(0, 1.2, 0)); // Ziel auf Brusth√∂he
          const turretGunPos = new THREE.Vector3();
          t.gun.getWorldPosition(turretGunPos);

          // Line-of-Sight Check: Ist eine Wand im Weg?
          raycaster.set(turretGunPos, targetPos.clone().sub(turretGunPos).normalize());
          const wallHit = worldBVH ? worldBVH.raycastFirst(raycaster.ray) : null;
          
          let hasLineOfSight = true;
          if (wallHit && wallHit.distance < distBest) {
            hasLineOfSight = false; // Da ist eine Wand im Weg
          }

          // Der gesamte Schwenk-Teil schaut auf den Gegner.
          // Das steuert sowohl die horizontale (Yaw) als auch vertikale (Pitch) Ausrichtung.
          if (hasLineOfSight) { // Turm zielt nur bei freier Sicht
            const worldTarget = new THREE.Vector3().copy(targetPos);
            t.swivel.lookAt(worldTarget);
          }

          // Schie√üen
          if (isShooting && hasLineOfSight) {
            const muzzlePos = new THREE.Vector3();
            t.barrels.getWorldPosition(muzzlePos); // Position der L√§ufe holen
            
            const projectileDir = new THREE.Vector3().subVectors(targetPos, muzzlePos).normalize();
            spawnProjectile(muzzlePos, projectileDir, t.damage);
    
            const light = new THREE.PointLight(0xfff0a3, 3, 4);
            light.position.copy(muzzlePos);
            scene.add(light);
            setTimeout(() => scene.remove(light), 60);

            t.cooldown = 1 / t.fireRate;
          }
        }

        // Laufrotation
        if (isShooting) {
          t.barrels.rotation.z += 30 * dt;
        }
      }
    }
    
    // --- Projektile ---
    function spawnProjectile(pos, dir, damage) {
      const geo = new THREE.SphereGeometry(0.06, 6, 4); // Projektile der T√ºrme
      const mat = new THREE.MeshBasicMaterial({ color: 0xfff0a3, transparent: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      const speed = 60;
      const p = { mesh, dir, damage, speed, life: 2, isPlayer: false };
      state.projectiles.push(p);
      scene.add(mesh);
    }

    function updateProjectiles(dt) {
      for (let i = state.projectiles.length - 1; i >= 0; i--) {
        const p = state.projectiles[i];
        p.mesh.position.addScaledVector(p.dir, p.speed * dt);
        p.life -= dt;

        let hit = false;
        // Spieler-Projektile haben keine Schadenslogik, da der Schaden sofort per Raycast angewendet wird.
        if (!p.isPlayer) {
          for (let j = state.enemies.length - 1; j >= 0; j--) {
            const e = state.enemies[j];
            // Pr√ºfe Kollision mit allen Hitboxen des Zombies
            let hitDetected = false;
            for (const hitbox of e.hitboxes) {
              const worldSphere = new THREE.Sphere().copy(hitbox.geometry.boundingSphere).applyMatrix4(hitbox.matrixWorld);
              if (worldSphere.containsPoint(p.mesh.position)) {
                hitDetected = true;
                break;
              }
            }
            if (hitDetected) {
              const wasKilled = e.takeDamage(p.damage, false);
              spawnSpark(p.mesh.position);
              if (wasKilled && !e.isDying) {
                e.die();
                setTimeout(() => {
                  e.isDead = true;
                }, 60000); // Zombie nach 1 Minute entfernen
                state.credits += 8 + Math.floor(state.wave * 1.5);
              }
              hit = true;
              break;
            }
          }
        }

        if (hit || p.life <= 0) {
          scene.remove(p.mesh);
          state.projectiles.splice(i, 1);
        }
      }
    }

    // --- Waves ---
    function getWaveConfig(wave) {
      const config = {
        count: 0,
        hpMultiplier: 1.0,
        typeDistribution: { run: 0, walk: 0, crawl: 0 }
      };

      // Basis-Anzahl und HP
      config.count = 20 + Math.floor(wave * 4); // Deutlich mehr Zombies pro Welle
      config.hpMultiplier = 1 + (wave - 1) * 0.08;

      // Verteilung der Zombie-Typen
      if (wave < 5) { // Anfangsphasen: Haupts√§chlich langsame
        config.typeDistribution.run = 0.1;
        config.typeDistribution.crawl = 0.3;
      } else if (wave < 20) { // Mittelphase: Ausgewogener Mix
        config.typeDistribution.run = 0.25;
        config.typeDistribution.crawl = 0.25;
      } else if (wave < 50) { // Sp√§tphase: Mehr schnelle Gegner
        config.typeDistribution.run = 0.4;
        config.typeDistribution.crawl = 0.15;
      } else { // End-Game: √úberwiegend schnelle und sehr schnelle
        config.typeDistribution.run = 0.6;
        config.typeDistribution.crawl = 0.1;
      }
      config.typeDistribution.walk = 1.0 - config.typeDistribution.run - config.typeDistribution.crawl;

      return config;
    }

    function startNextWave() {
      state.waveInProgress = true;
      const playerPos = controls.getObject().position;
      const waveConfig = getWaveConfig(state.wave);
      for (let i = 0; i < waveConfig.count; i++) {
        setTimeout(() => {
          spawnEnemy(waveConfig, playerPos);
        }, i * 200); // Spawne alle 200ms einen Zombie
      }
      updateHUD();
    }

    function updateWaves(dt) {
      if (state.enemies.length === 0 && !state.waveInProgress) {
        state.timeUntilNextWave -= dt;
        if (state.timeUntilNextWave <= 0) {
          state.wave++;
          showNotification(`Welle ${state.wave} beginnt!`, 2500, 'info');
          startNextWave(); state.timeUntilNextWave = 5;
        }
      }
    }

    function updateAmbientSpawns(dt) {
      if (!state.running || state.gameOver) return;

      state.timeUntilAmbientSpawn -= dt;
      if (state.timeUntilAmbientSpawn <= 0) {
        showNotification("Zus√§tzliche Gegner entdeckt!", 2000);
        const playerPos = controls.getObject().position;
        // Nutze die Konfiguration der aktuellen Welle (oder Welle 1, falls noch keine gestartet ist)
        const waveConfig = getWaveConfig(Math.max(1, state.wave));
        
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            spawnEnemy(waveConfig, playerPos);
          }, i * 150); // Spawne sie mit leichter Verz√∂gerung
        }
        state.timeUntilAmbientSpawn = 15; // Timer zur√ºcksetzen
      }
    }

    // --- Movement/Collision ---
    const keys = Object.create(null);

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'KeyP') togglePause();
      if (e.code === 'KeyR') restart();      

      // Digit-Shortcuts f√ºr Shop
      if (e.code === 'Digit1') {
        if (state.credits >= state.costs.turret) {
          state.credits -= state.costs.turret;
          placeTurret();
          state.costs.turret = Math.floor(state.costs.turret * 1.45 + 25);
          updateHUD();
        }
      }
      if (e.code === 'Digit2') {
        if (state.credits >= state.costs.dmg) {
          state.credits -= state.costs.dmg;
          state.damage += 5;
          state.costs.dmg = Math.floor(state.costs.dmg * 1.55 + 10);
          for (const t of state.turrets) {
            t.damage = Math.max(t.damage, Math.floor(state.damage * 0.6));
          }
          updateHUD();
        }
      }
      if (e.code === 'Digit3') {
        if (state.credits >= state.costs.rate && state.fireRate < 16) {
          state.credits -= state.costs.rate;
          state.fireRate = Math.min(16, state.fireRate + 1);
          state.costs.rate = Math.floor(state.costs.rate * 1.6 + 10);
          updateHUD();
        }
      }

      if (e.code === 'KeyT') {
        if (state.credits >= state.costs.turret) {
          state.credits -= state.costs.turret;
          placeTurret();
          state.costs.turret = Math.floor(state.costs.turret * 1.45 + 25);
          updateHUD();
        }
      }

      // Springen
      if (e.code === 'Space' && state.onGround) {
        state.vel.y = 6; // Sprungh√∂he/-kraft
        state.onGround = false;
      }
      if (state.running && ['KeyW','KeyA','KeyS','KeyD','ShiftLeft','ShiftRight','Digit1','Digit2','Digit3', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });

    const PLAYER_RADIUS = 0.4;
    function isColliding(pos) {
      const checkDirections = [ new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1) ];
      for (const dir of checkDirections) { // Pr√ºft jetzt in die korrekten, relativen Richtungen
        raycaster.set(pos, dir); // Raycaster neu setzen
        const hit = worldBVH ? worldBVH.raycastFirst(raycaster.ray) : null;
        if (hit && hit.distance < PLAYER_RADIUS) {
          return true; // Kollision, wenn eine Wand n√§her als der Spielerradius ist.
        }
      }
      return false;
    }

    function movePlayer(dt){
      const obj = controls.getObject();

      // --- Schwerkraft und Bodenkollision ---
      state.vel.y -= 9.8 * dt * 2.5; // St√§rkere Schwerkraft
      obj.position.y += state.vel.y * dt;

      // Raycaster f√ºr Bodenpr√ºfung
      raycaster.set(obj.position, new THREE.Vector3(0, -1, 0));
      const hit = worldBVH ? worldBVH.raycastFirst(raycaster.ray) : null; // BVH nutzen
      const onObject = hit; // `hit` ist entweder ein Objekt oder null
      if (onObject && hit.distance < CAMERA_HEIGHT) {
        // Wir sind auf dem Boden oder durch ihn gefallen.
        obj.position.y = hit.point.y + CAMERA_HEIGHT;
        state.vel.y = 0; // Vertikale Bewegung stoppen
        state.onGround = true;
      } else {
        // Wir sind in der Luft.
        state.onGround = false;
      }

      const base = state.speed;
      const speed = (keys.ShiftLeft || keys.ShiftRight) ? base * 1.7 : base;

      let moveX = 0, moveZ = 0;
      if (keys.KeyW) moveZ += 1;   // vorw√§rts
      if (keys.KeyS) moveZ -= 1;   // r√ºckw√§rts
      if (keys.KeyA) moveX -= 1;   // links
      if (keys.KeyD) moveX += 1;   // rechts

      if (moveX !== 0 || moveZ !== 0) {
        const len = Math.hypot(moveX, moveZ);
        moveX /= len; moveZ /= len;
      }

      // Richtungen aus Kamera, nur XZ
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const step = speed * dt;
      const dX = right.x * moveX * step + forward.x * moveZ * step;
      const dZ = right.z * moveX * step + forward.z * moveZ * step;

      // Achsenweise bewegen + kollidieren
      const oldX = obj.position.x;
      obj.position.x += dX;
      if (worldBVH && isColliding(obj.position)) {
        obj.position.x = oldX;
      }
      const oldZ = obj.position.z;
      obj.position.z += dZ;
      if (worldBVH && isColliding(obj.position)) {
        obj.position.z = oldZ;
      }
    }

    // --- Pointer Lock ---
    startBtn.addEventListener('click', () => { controls.lock(); });
    controls.addEventListener('lock',   () => { overlay.classList.add('hide'); state.running = true; controls.getObject().position.copy(spawnPos); });
    controls.addEventListener('unlock', () => { overlay.classList.remove('hide'); state.running = false; });

    // Maus-Schie√üen
    addEventListener('mousedown', (e)=>{ if (e.button===0) state._shootHeld = true; });
    addEventListener('mouseup',   (e)=>{ if (e.button===0) state._shootHeld = false; });

    // Buttons (optisch; Shop ist per Tasten gesteuert)
    el('pauseBtn').onclick = ()=> togglePause();
    el('restartBtn').onclick = ()=> restart();

    function togglePause(){ state.running = !state.running; overlay.classList.toggle('hide', state.running); }
    function gameOver(){ state.gameOver=true; state.running=false; overlay.classList.remove('hide'); overlay.querySelector('h1').textContent='Game Over'; }
    function restart(){
      for (const e of state.enemies) e.dispose();
      for (const t of state.turrets) scene.remove(t.base); state.turrets.length=0;
      state.enemies.length = 0;
      Object.assign(state, { running:true, gameOver:false, hp:100, credits:0, wave:0, time:0, damage:10, fireRate:6, lastShot:0, enemies:[], turrets:[], projectiles:[], costs:{turret:100,dmg:80,rate:90}, speed:10, friction:10, vel:new THREE.Vector3(), waveInProgress: false, timeUntilNextWave: 5, timeUntilAmbientSpawn: 15 });
      overlay.classList.add('hide');
      controls.getObject().position.copy(spawnPos);
      updateHUD();
    }

    // --- Resize ---
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // --- Self-Tests ---
    const results = []; const ok = (name, cond) => results.push({ name, ok: !!cond });
    ok('THREE vorhanden', !!THREE.WebGLRenderer);
    ok('PointerLockControls vorhanden', typeof PointerLockControls === 'function');
    ok('Helligkeit (exposure)', renderer.toneMappingExposure >= 1.6);

    // --- Loop ---
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000); last = now;
      if (state.running && !state.gameOver){
        state.time += dt;
        movePlayer(dt);
        if (state._shootHeld) shoot();
        updateWaves(dt);
        updateAmbientSpawns(dt);
        enemyAI(dt);
        turretsAct(dt);
        updateHUD();
        updateProjectiles(dt);
      }
      updateSparks(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Init HUD
    updateHUD();
  </script>
</body>
</html>